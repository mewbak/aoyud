// Shunting-yard parsing of arithmetic expressions.

package main

import (
	"bytes"
	"fmt"
	"strings"
)

// Eh, why not, helps debugging.
type OperatorID string

const (
	opPlus  = "+"
	opMinus = "-"
	opMul   = "*"
	opDiv   = "/"
	opMod   = "MOD"
	opShL   = "SHL"
	opShR   = "SHR"

	opAnd = "AND"
	opOr  = "OR"
	opXor = "XOR"

	opEq = "EQ"
	opNe = "NE"
	opLt = "LT"
	opLe = "LE"
	opGt = "GT"
	opGe = "GE"

	opNot = "NOT"

	opParenL = "("
	opParenR = ")"

	opPtr = "PTR"

	opDup = "DUP"
)

type shuntOp struct {
	id         OperatorID
	precedence int
	args       int
	function   interface{} // Function to apply to the operands.
}

func (op *shuntOp) Thing() string {
	return "arithmetic operator"
}

func (op *shuntOp) String() string {
	return string(op.id)
}

type shuntOpMap map[string]shuntOp

type shuntStack struct {
	vals []Thingy
	unit DataUnit
}

func (stack *shuntStack) String() string {
	return fmt.Sprintf("%v (%d-byte units)", stack.vals, stack.unit.Width())
}

func (stack *shuntStack) push(element Thingy) {
	stack.vals = append(stack.vals, element)
}

func (stack *shuntStack) peek() Thingy {
	if length := len(stack.vals); length != 0 {
		return stack.vals[length-1]
	}
	return nil
}

func (stack *shuntStack) pop() (Thingy, ErrorList) {
	if ret := stack.peek(); ret != nil {
		stack.vals = stack.vals[:len(stack.vals)-1]
		return ret, nil
	}
	return nil, ErrorListF(ESError, "arithmetic stack underflow")
}

// Why, Go, why.
func b2i(b bool) int64 {
	if b {
		return 1
	}
	return 0
}

var asmTypes = map[string]asmInt{
	"?":     {n: 0},
	"BYTE":  {n: 1},
	"WORD":  {n: 2},
	"DWORD": {n: 4},
	"PWORD": {n: 6},
	"FWORD": {n: 6},
	"QWORD": {n: 8},
	"TBYTE": {n: 10},
}

var unaryOperators = shuntOpMap{
	"(":   {opParenL, 1, 0, nil},
	")":   {opParenR, 1, 0, nil},
	"+":   {opPlus, 6, 1, func(a *asmInt) {}},
	"-":   {opMinus, 6, 1, func(a *asmInt) { a.n = -a.n }},
	"NOT": {opNot, 11, 1, func(a *asmInt) { a.n = ^a.n }},
}

var binaryOperators = shuntOpMap{
	"DUP": {opDup, 15, 2, nil},
	"(":   {opParenL, 1, 0, nil},
	")":   {opParenR, 1, 0, nil},
	"PTR": {opPtr, 11, 2, func(a, b *asmInt) {
		a.ptr = uint64(a.n)
		a.n = b.n
		a.base = b.base
	}},
	"*":   {opMul, 8, 2, func(a, b *asmInt) { a.n *= b.n }},
	"/":   {opDiv, 8, 2, func(a, b *asmInt) { a.n /= b.n }},
	"MOD": {opMod, 8, 2, func(a, b *asmInt) { a.n %= b.n }},
	"SHR": {opShR, 8, 2, func(a, b *asmInt) { a.n >>= uint(b.n) }},
	"SHL": {opShL, 8, 2, func(a, b *asmInt) { a.n <<= uint(b.n) }},
	"+":   {opPlus, 9, 2, func(a, b *asmInt) { a.n += b.n }},
	"-":   {opMinus, 9, 2, func(a, b *asmInt) { a.n -= b.n }},
	"EQ":  {opEq, 10, 2, func(a, b *asmInt) { a.n = b2i(a.n == b.n) }},
	"NE":  {opNe, 10, 2, func(a, b *asmInt) { a.n = b2i(a.n != b.n) }},
	"LT":  {opLt, 10, 2, func(a, b *asmInt) { a.n = b2i(a.n < b.n) }},
	"LE":  {opLe, 10, 2, func(a, b *asmInt) { a.n = b2i(a.n <= b.n) }},
	"GT":  {opGt, 10, 2, func(a, b *asmInt) { a.n = b2i(a.n > b.n) }},
	"GE":  {opGe, 10, 2, func(a, b *asmInt) { a.n = b2i(a.n >= b.n) }},
	"AND": {opAnd, 12, 2, func(a, b *asmInt) { a.n &= b.n }},
	"OR":  {opOr, 13, 2, func(a, b *asmInt) { a.n |= b.n }},
	"|":   {opOr, 13, 2, func(a, b *asmInt) { a.n |= b.n }},
	"XOR": {opXor, 13, 2, func(a, b *asmInt) { a.n ^= b.n }},
}

type shuntConcatenator struct{}

func (c shuntConcatenator) Thing() string {
	return "comma"
}

func (c shuntConcatenator) String() string {
	return ","
}

type strucInitializer byte

const (
	sOpen  strucInitializer = '<'
	sClose                  = '>'
)

func (s strucInitializer) Thing() string {
	if s == sOpen {
		return "start of structure initializer"
	}
	return "end of structure initializer"
}

func (s strucInitializer) String() string {
	return string(s)
}

type strucInstance struct {
	Type *asmStruc
	// Total size of the custom structure members on the stack that can appear
	// before closing this instance.,
	CustomBytes uint
}

func (s strucInstance) Thing() string {
	return "structure instance"
}

func (s strucInstance) String() string {
	return fmt.Sprintf("%s(%d custom bytes)", s.Type.Name(), s.CustomBytes)
}

func (s *strucInstance) Next() DataUnit {
	if s.CustomBytes >= s.Type.Width() {
		return nil
	}
	blob := s.Type.data[s.CustomBytes]
	bloblen := (*blob.Data).Len()
	s.CustomBytes += bloblen
	if len(blob.Ptrs) > 0 {
		return blob.Ptrs[0].unit
	}
	switch (*blob.Data).(type) {
	case *asmStruc:
		return (*blob.Data).(*asmStruc)
	}
	return SimpleData(bloblen)
}

type Emittable interface {
	fmt.Stringer
	Emit() []byte
	// Len returns the total number of bytes that would be generated by a call
	// to Emit.
	Len() uint
}

// Since you can only go from integers to bytes, but not back, this saves us
// from having to needlessly implement Emit() for all Calcables.
type CalcToEmitOperator struct {
	Calc Calcable
}

func (cte CalcToEmitOperator) String() string {
	return cte.Calc.String()
}

func (cte CalcToEmitOperator) Emit() []byte {
	return cte.Calc.Calc().Emit()
}

func (cte CalcToEmitOperator) Len() uint {
	return cte.Calc.Calc().Len()
}

type DUPOperator struct {
	Count Calcable
	Data  Emittable
}

func (dup DUPOperator) String() string {
	return fmt.Sprintf("(%s DUP(%s))", dup.Count, dup.Data)
}

func (dup DUPOperator) Emit() []byte {
	return bytes.Repeat(dup.Data.Emit(), int(dup.Count.Calc().n))
}

func (dup DUPOperator) Len() uint {
	return dup.Data.Len() * uint(dup.Count.Calc().n)
}

type DataArray []Emittable

func (d DataArray) Thing() string {
	return "data array"
}

func (d DataArray) String() string {
	ret := "("
	for i, data := range d {
		if i != 0 {
			ret += ", "
		}
		ret += data.String()
	}
	return ret + ")"
}

func (d DataArray) Emit() (ret []byte) {
	for _, data := range d {
		ret = append(ret, data.Emit()...)
	}
	return ret
}

func (d DataArray) Len() (ret uint) {
	for _, data := range d {
		ret += data.Len()
	}
	return ret
}

type Calcable interface {
	fmt.Stringer
	Calc() asmInt
}

// No point in defining separate types for the callback functions of unary and
// binary operators, since you can't do type assertions with them anyway, for
// some bizarre reasonâ€¦

type UnaryOperator struct {
	ID       OperatorID
	Function func(a *asmInt)
	Operand  Calcable
}

type BinaryOperator struct {
	ID       OperatorID
	Function func(a, b *asmInt)
	Operands [2]Calcable
}

func (v asmInt) Calc() asmInt {
	return v
}

func (op BinaryOperator) String() string {
	return fmt.Sprintf("(%s %s %s)", op.Operands[0], op.ID, op.Operands[1])
}

func (op BinaryOperator) Calc() asmInt {
	a, b := op.Operands[0].Calc(), op.Operands[1].Calc()
	op.Function(&a, &b)
	return a
}

func (op UnaryOperator) String() string {
	return fmt.Sprintf("(%s %s)", op.ID, op.Operand)
}

func (op UnaryOperator) Calc() asmInt {
	a := op.Operand.Calc()
	op.Function(&a)
	return a
}

// nextShuntToken returns the next operand or operator from s. Only operators
// in opSet are identified as such.
func (s *SymMap) nextShuntToken(stream *lexStream, opSet *shuntOpMap) (ret Thingy, err ErrorList) {
	token := stream.nextToken(shuntDelim)
	if isAsmInt(token) {
		return newAsmInt(token)
	} else if len(token) == 1 {
		if quote := token[0]; quotes.matches(quote) {
			token = stream.nextString(charGroup{quote})
			err = stream.nextAssert(quote, token)
			return asmString(token), err
		} else if token[0] == ',' {
			return shuntConcatenator{}, err
		} else if token[0] == '<' {
			return strucInitializer(sOpen), err
		} else if token[0] == '>' {
			return strucInitializer(sClose), err
		}
	}
	tokenUpper := strings.ToUpper(token)
	if typ, ok := asmTypes[tokenUpper]; ok {
		return typ, err
	} else if nextOp, ok := (*opSet)[tokenUpper]; ok {
		return &nextOp, err
	}
	return s.Get(token)
}

// pushOp evaluates newOp, a newly incoming operator, in relation to the
// previous operators on top of opStack, and returns the next set of allowed
// operators.
func (retStack *shuntStack) pushOp(opStack *shuntStack, newOp *shuntOp) (*shuntOpMap, ErrorList) {
	switch newOp.id {
	case opParenR:
		var err ErrorList
		top, _ := opStack.pop()
		for top != nil && top.(*shuntOp).id != opParenL {
			retStack.push(top)
			top, _ = opStack.pop()
		}
		if top == nil {
			err = ErrorListF(ESError, "mismatched parentheses")
		}
		return &binaryOperators, err
	case opParenL:
		opStack.push(newOp)
	default:
		for top := opStack.peek(); top != nil; top = opStack.peek() {
			op := top.(*shuntOp)
			if op.id == opParenL || newOp.precedence <= op.precedence {
				break
			}
			retStack.push(op)
			opStack.pop()
		}
		opStack.push(newOp)
	}
	return &unaryOperators, nil
}

type shuntState struct {
	retStack shuntStack
	opStack  shuntStack
	opSet    *shuntOpMap
	// Slice of currently open structures
	structs []strucInstance
	// Data type of the currently evaluated value, or nil if the end of the
	// expression has been reached.
	curUnit DataUnit
}

func (s *shuntState) nextStrucElm() DataUnit {
	if len(s.structs) < 1 {
		return nil
	}
	return s.structs[len(s.structs)-1].Next()
}

func (s *shuntState) leaveStrucInstance() (err ErrorList) {
	if len(s.structs) == 0 {
		return err.AddF(ESError, "can't close an unopened structure instance")
	}
	s.curUnit = nil
	s.retStack.push(s.structs[len(s.structs)-1])
	s.structs = s.structs[:len(s.structs)-1]
	s.opSet = &binaryOperators
	return nil
}

func (s *SymMap) shuntNext(state *shuntState, stream *lexStream) (bool, ErrorList) {
	defer stream.ignore(whitespace)

	tokenPos := stream.c
	token, err := s.nextShuntToken(stream, state.opSet)
	if err.Severity() >= ESError {
		return false, err
	}

	tokenErr := func(text string) (bool, ErrorList) {
		return false, err.AddF(ESError, "%s: %s", text, stream.input[tokenPos:])
	}

	// Structure initializers and operators need to be handled before value
	// types in order to keep state.curUnit (in)valid.
	switch token.(type) {
	case strucInitializer:
		state.opSet = &unaryOperators

		si := token.(strucInitializer)
		switch state.retStack.unit.(type) {
		case *asmStruc:
			if si == sClose {
				return true, err.AddL(state.leaveStrucInstance())
			}
			switch state.curUnit.(type) {
			case *asmStruc:
				struc := state.curUnit.(*asmStruc)
				state.structs = append(state.structs, strucInstance{Type: struc})
				state.curUnit = state.nextStrucElm()
				state.retStack.push(si)
				return true, err
			}
			// TODO: Print the name of the structure member?
			return tokenErr("expected an arithmetic expression, not a structure")
		}
		return false, err.AddF(ESError,
			"angle brackets (<>) are invalid for non-structure type",
		)
	case shuntConcatenator:
		if len(state.structs) > 0 {
			state.curUnit = state.nextStrucElm()
			if state.curUnit == nil {
				return tokenErr("too many elements in structure initializer")
			}
			return true, err
		}
		return false, err
	}
	if state.curUnit == nil {
		return tokenErr("expression after data initializer")
	}
	wordsize := state.curUnit.Width()
	switch token.(type) {
	case asmInt:
		// Needs to be here since we also need to take care of predefined
		// constants like '?'.
		integer := token.(asmInt)
		integer.wordsize = uint8(wordsize)
		state.retStack.push(integer)
		state.opSet = &binaryOperators
	case asmString:
		if wordsize > 1 {
			var errInt ErrorList
			token, errInt = token.(asmString).Int(wordsize)
			err = err.AddL(errInt)
		}
		state.retStack.push(token)
		state.opSet = &binaryOperators
	case *shuntOp:
		var errOp ErrorList
		op := token.(*shuntOp)
		state.opSet, errOp = state.retStack.pushOp(&state.opStack, op)
		err = err.AddL(errOp)

		if op.id == opDup {
			arg := stream.nextNestedString(dupDelim)
			if len(arg) == 0 {
				return false, err.AddF(ESError, "missing data argument for DUP")
			} else if arg[0] != '(' || arg[len(arg)-1] != ')' {
				return false, err.AddF(ESError,
					"data argument to DUP must be enclosed in parentheses: %s",
					arg,
				)
			}
			var data Emittable
			var errData ErrorList
			var array DataArray
			dupStream := NewLexStreamAt(stream.pos, arg[1:len(arg)-1])
			for dupStream.peek() != eof && errData.Severity() < ESError {
				data, errData = s.shuntData(dupStream, state.retStack.unit)
				err = err.AddL(errData)
				if data != nil && errData.Severity() < ESError {
					array = append(array, data)
				}
			}
			state.retStack.push(array)
			state.curUnit = nil
		}
	case asmExpression:
		stream.input = string(token.(asmExpression)) + stream.input[stream.c:]
		stream.c = 0
	default:
		err = err.AddF(ESError,
			"can't use %s in arithmetic expression", token.Thing(),
		)
	}
	return true, err
}

func (s *SymMap) shunt(stream *lexStream, unit DataUnit) (stack *shuntStack, err ErrorList) {
	state := shuntState{
		opSet:    &unaryOperators,
		retStack: shuntStack{unit: unit},
		curUnit:  unit,
	}
	moreTokens := true
	for stream.peek() != eof && moreTokens && err.Severity() < ESError {
		var errShunt ErrorList
		moreTokens, errShunt = s.shuntNext(&state, stream)
		err = err.AddL(errShunt)
	}
	if err.Severity() >= ESError {
		return nil, err
	}
	for top := state.opStack.peek(); top != nil; top = state.opStack.peek() {
		state.opStack.pop()
		if top.(*shuntOp).id == opParenL {
			err = err.AddF(ESError, "missing a right parenthesis")
		} else {
			state.retStack.push(top)
		}
	}
	for len(state.structs) > 0 {
		err = err.AddF(ESWarning, "missing a closing >")
		err = err.AddL(state.leaveStrucInstance())
	}
	switch state.retStack.unit.(type) {
	case *asmStruc:
		if state.curUnit != nil {
			err = err.AddF(ESError,
				"structure instances must be initialized using angle brackets (<>): %s",
				stream.input,
			)
		}
	}
	return &state.retStack, err
}

// shuntData wraps shunt and ToEmitTree.
func (s *SymMap) shuntData(stream *lexStream, unit DataUnit) (Emittable, ErrorList) {
	stack, err := s.shunt(stream, unit)
	if err.Severity() < ESError {
		tree, errTree := stack.ToEmitTree()
		return tree, err.AddL(errTree)
	}
	return nil, err
}

func (s *shuntStack) processCalcOp(op *shuntOp) (ret Calcable, err ErrorList) {
	if op.function != nil {
		if op.args == 2 {
			var err0, err1 ErrorList
			ret := BinaryOperator{
				ID: op.id, Function: op.function.(func(*asmInt, *asmInt)),
			}
			ret.Operands[1], err1 = s.ToCalcTree()
			ret.Operands[0], err0 = s.ToCalcTree()
			err = err.AddL(err1)
			err = err.AddL(err0)
			return ret, err
		} else if op.args == 1 {
			var err0 ErrorList
			ret := UnaryOperator{
				ID: op.id, Function: op.function.(func(*asmInt)),
			}
			ret.Operand, err0 = s.ToCalcTree()
			return ret, err.AddL(err0)
		}
	}
	return nil, err.AddF(ESError,
		"%s not allowed in arithmetic expression", op.String(),
	)
}

func (s *shuntStack) ToCalcTree() (Calcable, ErrorList) {
	root, err := s.pop()
	switch root.(type) {
	case nil:
		return nil, err
	case *shuntOp:
		op, errOp := s.processCalcOp(root.(*shuntOp))
		return op, err.AddL(errOp)
	case asmInt:
		return root.(asmInt), err
	case asmString:
		wordsize := s.unit.Width()
		if wordsize == 1 {
			wordsize = 0
		}
		integer, errInteger := root.(asmString).Int(wordsize)
		return integer, err.AddL(errInteger)
	}
	return nil, err.AddF(ESError,
		"can't use %s in arithmetic expression", root.Thing(),
	)
}

func (s *shuntStack) ToEmitTree() (Emittable, ErrorList) {
	root, err := s.pop()
	switch root.(type) {
	case nil:
		return nil, err
	case strucInstance:
		var customData BlobList
		instance := root.(strucInstance)
		i := instance.CustomBytes

	ElementLoop:
		for top := s.peek(); top != nil && err.Severity() < ESError; top = s.peek() {
			switch top.(type) {
			case strucInitializer:
				break ElementLoop
			}
			data, errData := s.ToEmitTree()
			err = err.AddL(errData)
			if errData.Severity() >= ESError {
				return nil, err
			}
			i--
			switch instance.Type.flag {
			case sStruc:
				if len(customData) == 0 {
					customData = append(customData, instance.Type.data...)
				}
				// TODO: This overwrites the hierarchy of nested structures.
				// Do we actually need it?
				var customErr ErrorList
				customData, customErr, i = customData.Set(i, data)
				err = err.AddL(customErr)
			case sUnion:
				customData = customData.Append(nil, data)
				customData = customData.Expand(nil, 0, instance.Type.Width())
			}
		}
		_, popErr := s.pop()
		err = err.AddL(popErr)
		if len(customData) == 0 {
			return instance.Type, err
		}
		ret := *instance.Type
		ret.data = customData
		return ret, err
	case *shuntOp:
		op := root.(*shuntOp)
		switch op.id {
		case opDup:
			data, errData := s.ToEmitTree()
			count, errCount := s.ToCalcTree()
			err = err.AddL(errData)
			err = err.AddL(errCount)
			return DUPOperator{count, data}, err
		}
		cOp, errCOp := s.processCalcOp(root.(*shuntOp))
		return CalcToEmitOperator{cOp}, err.AddL(errCOp)
	case asmInt:
		return root.(asmInt), err.AddL(s.fitsInStack(root.(asmInt)))
	case asmString:
		return root.(asmString), err
	case DataArray:
		return root.(DataArray), err
	}
	return nil, err.AddF(ESError,
		"can't use %s in data expression", root.Thing(),
	)
}

// fitsInStack returns an error if v doesn't fit into the stack's word size.
func (s shuntStack) fitsInStack(v asmInt) ErrorList {
	wordsize := s.unit.Width()
	if v.FitsIn(wordsize) {
		return nil
	}
	return ErrorListF(ESError, "number exceeds %d bits: %s", wordsize*8, v)
}

// solveInt wraps solve and enforceIntResult.
func (s shuntStack) solveInt() (*asmInt, ErrorList) {
	tree, err := s.ToCalcTree()
	if err.Severity() < ESError {
		ret := tree.Calc()
		return &ret, err.AddL(s.fitsInStack(ret))
	}
	return nil, err
}

// evalInt wraps shunt and solveInt.
func (s *SymMap) evalInt(pos ItemPos, expr string) (*asmInt, ErrorList) {
	stream := NewLexStreamAt(pos, expr)
	stack, err := s.shunt(stream, SimpleData(maxbytes))
	if err.Severity() < ESError {
		ret, errSolve := stack.solveInt()
		return ret, err.AddL(errSolve)
	}
	return nil, err
}

// evalBool wraps evalInt and casts its result to a bool.
func (s *SymMap) evalBool(pos ItemPos, expr string) (bool, ErrorList) {
	ret, err := s.evalInt(pos, expr)
	if err.Severity() < ESError {
		return ret.n != 0, err
	}
	// Default to false in the case of an error... for now, at least.
	return false, err
}

// evalData calls shuntData for all comma-separated elements in expr.
func (s *SymMap) evalData(pos ItemPos, expr string, unit DataUnit) (ret DataArray, err ErrorList) {
	stream := NewLexStreamAt(pos, expr)
	for stream.peek() != eof && err.Severity() < ESError {
		data, errData := s.shuntData(stream, unit)
		err = err.AddL(errData)
		if data != nil {
			ret = append(ret, data)
		}
	}
	return ret, err
}
